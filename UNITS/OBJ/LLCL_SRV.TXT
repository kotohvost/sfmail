
                    Описание DOS ASYNC Server

10.12.96!!!NEW!!! Теперь в функцию InitFLib первым параметром
передается номер порта

15.09.96!!!NEW!!! Сделана зытычка баги эмулятор MNP MX5 и MNP Level 5
Driver v1.30 by DWLab. Теперь мы сними работаем. Причем и на гидре
должны тоже без всяких патчей. Изменились номера типов дрыверов:
БЫЛО
      BNU = 1
      X00 = 2
      VX00 = 3
      Unknown = 4-0F
      LLCL >= 10h
Стало:
      BNU = 1
      X00 = 2
      VX00 = 3
      MNP = 4
      Unknown = 5-0F
      LLCL >=10h

22.02.96!!!NEW!!! Сделана затычка баги SIO 1.35 - 1.44 с потерей RTS
сигнала. Также изменились номера типов драйверов:
БЫЛО BNU -1, X00 -2 Unknown 3-0F СТАЛО VX00 - 3, Unknown 4-0F

09:02.96!!!FIX!!! Исправлена неработоспособность с VX00
Также из за изменения спецификации LLCL API, при обнаружении драйверов
ревизии ниже 1.02 возвращается ошибка TERR_ILLVER - некоректная ревизия
ком драйвера.

02.02.96!!!FIX!!! Испроавлено пара злобных багов ( лишние POP в двух
функциях)
!!!NEW!!! Функция ReceiveCtrl - управление приемом. Для меделнных тачек
чтоб байты не терялись при записи на диск.

26.12.95!!!FIX!!! Исправлена бага которая приводила к невозможности
установки скорости выше 2400 при незалоченом в BNU порте.

21.12.95!!!NEW!! Убрана таблица хэндлов. Вставлена проверка присутствия
фоссила в функцию Resume. Если во время свопинга фоссил пропал то это
будет обнаружено и библиотека полностью деинициализирована.
И будет возвращен код ошибки TERR_NOLIB. В этом случае надо попробовать
полностью переинициализировать библиотеку функцией InitFLib и если она вернет
код TERR_NOFOSS то закончить работу с сообщение что фоссил не найден. Иначе
открыть канал и так далее - тоесть произвести обычную процедуру инициализации
как при старте мэйлера.


13.12.95!!!NEW!! Изменилась структура PORTPARAM (используется при установке
параметров порта в функциях открытия канала, и других) - добавлено поле
wPortHandl - хэндл порта. Хэндл можно получить после открытия канала
с помощью функции GetPortInfo.

08.12.95!!!NEW!! Добавлена установка скоростей выше 38400 в X00
и других фоссилах поддерживающих функции выше 1Eh
!!!NOTE!! С хаками X00 (версии выше 1.53) возможно не работает

10.07.95!!!NEW!! Изменен способ опознавания LLCL
24.06.95!!!BugFix!!! Непроставлялся RI в HardStat при работе с LLCLCOM
24.06.95!!!BugFix!!! Бага с зависом при обращении к фоссилу в старом стиле

22.06.095!!!NEW+BugFix!!!

     Исправлена бага с фоссилом X00 (неинициализация скорости)
которая насамом деле бага самого X00.
     Cделана поддержка LLCL драйверов.

28.04.95
!!!Bug Fix!!! С багой с порчей регистров при вызове отдатчика времени

27.02.95
!!!NOTE!!!
Появились новые поля в структуре LibInfo.
     Это:
     fpAESStack,
     fpServerStack,
     wCPUID.
     Появился новый бит в битовой записи rLibFlags это 4-тый бит.
     Изменились значения битов 2 и 3 (генератор первичных событий
AES) битовой записи rLibFlags. Смотри описание rLibInfo и функции
InitFLIB.
     Изменены названия полей в LibInfo. Изменено так:
     vDrvType -> wDrvType
     vTStckSize -> wAESStckSize
     vServerStckSize -> wServerStckSize

Подробнее смотри описание структуры LibInfo  и  описание  функции
InitFLib.
Все изменения отражены в файле декларайий  констант,  структур  и
функций - LLCL.H

──────────────────────────────────────────────────────────────────────
!!!!!!!!!!NOTE!!!! Исправлен баг с Close/Open Chanel
!!!!NOTE!!! Появилась новая функция ChangeTimeOut
!!!!NOTE!!! Появилась новая функция Suspend и Resume (смотри файл AES.TXT)
!!!!NOTE!!! Новый код ошибки - AERRNOAES
!!!!NOTE!!!  Изменения  в  формате   битовой   записи   rLibFlags
структуры LibInfo.
!!!!NOTE!!! Все константы и структуры определены в файле LLCL.H в
формате паскаля и готовом к прямому использованию в  паскалевском
модуле.

──────────────────────────────────────────────────────────────────────
СОГЛОШЕНИЕ О ВОЗВРАЩАЕМЫХ ФУНКЦИЯМИ ЗНАЧЕНИЯХ:

     Все функции библиотеки возвращают значение типа integer
     Кроме случаев когда отдельно оговорено другое
     НО в случае ошибки это всегда отрицательное число
     В случае успеха возвращается  число > 0
     В случае если функция возвращает  принятый
     символ то число также положительное и является на самом
     деле байтом - старший байт равен 0
     В случае блочной передачи возвращается результат сколько
     принято/передано  тоже положительное число но слово}

─────────────────────────────────────────────────────────────────────────

                      СТРУКТУРЫ И КОНСТАНТЫ

const
константы ошибок
        TERR_REENT:integer = -1 ; {ошибка повторной попытки проинитить либу}
       *TERR_NOMEM :integer= -2 ; {нет памяти под всякие внутренний дела*}
        TERR_NOLIB :integer= -3  ;{ошибка попытки вызвать функцию непроинитив
        перед этим либу}
        TERR_ACTIV :integer= -4  ; {Канал уже открыт(при повторной попытке от
        крыть канал}
        TERR_TSSBUSY :integer= -5 ; {в данный момент уже выполняется какая
        либо функция библиотеки}
        TERR_NOACTIV :integer= -6 ;{канал не открыт}
        TERR_ARG :integer= -7   ;  {аргумент функции неверен}
        TERR_NOFOSS :integer= -8 ; {фоссил не резидентен}
       *TERR_NOROOM :integer= -9 ; {нет ячейки в списке задачь}
        TERR_PORTN :integer= -10 ; {неверный номер порта}
        TERR_RXEMPTY :integer= -11 ; {буфер приема пуст}
        TERR_TXFULL :integer= -12  ; {буфер передачи полон}
        TERR_ILLVER :integer= -13  ; {старая версия фоссила}
        TERR_TOUT :integer= -14  ; {таймаут}
       *TERR_NIMPL :integer= -$FF ;  {нет такой функции в либе(пустая
функция)}
        AERRNOAES :integer= -$40 ; AES не инициализирован

Что касается ошибок, то те которые обозначены звездочкой в данной
версии библиотеки никогда не возникают.  Ошибка не  верный  номер
порта возникает :

1.в функции OpenChanel в случае если номер порта в структуре типа
PortParam превышает $FFh

2.в функции SetPort в  случае  если  номер  порта  во  внутренней
структуре библиотеки и  в  структуре  указатель  на  которую  был
передан (типа PortParam) не совпадают Чтобы избежать этой  ошибки
, нужно сначала поменять номер порта с которым работает канал,  с
помощью функции ChangeChanelPort

3. в функции ChangeChanelPort в том же случае что и OpenChanel
4.  в функции GetXtendPortStat в  том  случае  если  текущий  тип
драйвера есть  фоссил  (переменная  vDrvType  структуры  sLibInfo
меньше или равна 3-ем), а текущий порт превышает 3 (COM4)

Ошибки типа RXEMPTY  или  TXFULL  возникают  при  вводе/выводе  с
помощью функций записи/чтения без ожидания(в том числе и блочных)

Ошибка TOUT возникает в функциях ввода/вывода с ожиданием.

Ошибка ILLVER возникает при получении информации от  фоссила  так
как фоссил ревизии меньше 5-ой  не  поддерживает  соответствующую
функцию}

{константы управления потоком}
        FL_LOCK:byte=$80;  {лочить порт}
        FL_DCD:byte=$40;   {следить за пропаданием DCD}
        FL_XX:byte=$20;    {пропускать XON/XOFF(только если softflow)}
        FL_RXSOFT:byte=$8; {soft flow на прием}
        FL_ALTHARDW:byte=$4;   {DTR/DSR  этот  тип  не  совместим  с
большинством фоссилов потому его не рекомендуется устанавливать}

        FL_HARDW:byte=$2;  {hard flow}
        FL_TXSOFT:byte=$1; {sowt flow на передачу}

Эти константы определены специально для вашего  удобства  друзья
паскалисты! Так как в вашем сраном Паскале нет битовых записей, а
у меня они используются то вот.  Эти константы для  инициализации
поля rFlowCtrl в записи(структуре) типа PortParam  и  служат  для
установки способа управления потоком(описание  битов  этого  поля
смотри ниже в описании PortParam)  Привожу  пример  инициализации
поля  rFlowCtrl  для  следующих  установок  :  порт  лочен,   DCD
отслеживается , управление потоком RTS/CTS

        var sPortParam:PortParam;

        sPortParam.rFlowCtrl:=(FL_LOCK or FL_DCD or FL_HARDW);

В далнейшем для сброса каково либо бита можно (и нужно делать так):
выключаем например слежение за DCD


        sPortParam.rFlowCtrl:=(sPortParam.rFlowCtrl and (not FL_DCD))

}

{константы для удобства разбора слова возвращаемого функцией GetPortStat}

        ST_TXEMPT=$4000; { буфер передачи пуст}
        ST_TXAV=$2000;  {в буфере передачи есть место}
        ST_OVRN=$0200;  {буфер приема был переполнен}
        ST_RDA=$0100;   {есть данные в буфере приема}
        ST_DCD=$0080; {есть несущая}
        ST_RING=$0040; {есть звонок}
        ST_DTR=$0002; {DTR активен}
        ST_PREVDCD=$0001; {Предыдущие состояние DCD}
{пример использования(про GetPortStat смотри ниже):

4321:
        if (GetPortStat and ST_DCD) true then goto 1234;
        goto 4321;
1234:
}

{константы для удобства установки параметров порта}

  SP110=0;     {110 бод   }
  SP150=1;     {150 бод   }
  SP300=2;     {300 бод   }
  SP600=3;     {600 бод   }
  SP1200=4;    {1200 бод  }
  SP2400=5;    {2400 бод  }
  SP4800=6;    {4800 бод  }
  SP9600=7;    {9600 бод  }
  SP19200=8;   {19200 бод }
  SP38400=9;   {38400 бод }
  SP57600=10;  {57600 бод }
  SP115200=11; {115200 бод}

        BIT5=5; { 5 бит данных}
        BIT5=6; { 6 бит данных}
        BIT5=7; { 7 бит данных}
        BIT5=8; { 8 бит данных}

        STOP1=1; { 1 стоп бит }
        STOP2=2; { 2 стоп бит }

        NOPARITY=0;   { без контроля четности}
        ODDPARITY=1;  { контроль нечетности }
        EVENPARITY=2; { контроль четности }

{запись(структура) информации о библиотеке}
        type LibInfo=record
                pReleaseSlice:pointer;
                fpAESStack:pointer;
                fpServerStack:pointer;
                wAESStckSize:word;
                wServerStckSize:word;
                cLibver:word;
                cFossilRev:byte;
                cDriverRev:byte;
                cMaxFossFunc:byte;
                pDrvName:pointer;
                rLibFlags:byte;
                wDrvType:word;
                bCPUID:byte;
          end;

{Что касается LibInfo:

Указатель на эту структуру вы передаете  при  вызове  InitFLib  В
этой структуре обязательно должны быть  вами  проинициализированы
следующие поля:

     pReleaseSlice это указатель на процедуру освобождения кванта
времени указатель должен быть дальним ,  если  у  вас  нет  такой
процедуры то проинициализируйте его в нуль ОБЯЗАТЕЛЬНО.

     fpAESStack это  дальний  указатель  на  стек  который  будет
использовать AES при выполнении своих  функций.  Если  переменная
wAESStckSize(см.  ниже) проинициализирована в ноль то это поле не
используется,  но я рекомендую либо инициализировать  его  в  NIL
либо    давать    нормальное    значение.    Например    например
проинициализировать это поле можно так:

     GetMem(sLibInfo.fpAESStack, sLibInfo.wAESStckSize);

     fpServerStack - проинициализируте его в NIL.

     wAESStckSize задает  размер  внутреннего  стека  AES,  имеет
размерность слова,тоесть не может превышать 65535 байт.  Если  вы
инициализируете это поле в ноль, то AES не будет переключать стек
при выполнении своих функций.

 wServerStckSize  проинициализируйте в 0

 rLibFlags представляет из себя битовую запись в которой
 бит 0 - флаг доступности AES (Asynchronous Event Sheduler)
 Этот Бит будет установлен при возврате из библиотеки

 бит  1  -  устанавливает  способ  вызова  фоссила   если   1  то
устанавливается  NewStyle,  если  0  то  OldStyl  остальные  биты
зарезервированы (должны быть в 0).
     NewStyle - вызов фоссила через far call
     OldStyle - вызов фоссила через INT 14h
     При использовании LLCL  драйвера  этот  бит  игнорируется  и
вызов производится всегда через far call.

 биты 3 и 2 задают кто будет являтся генератором событий AES
 00 - фоссил
 01 - таймер прерывание 8
 10 - таймер прерывание 1Сh.
 11 - часы реального времени.

     Я  настоятельно  не   рекомендую   пользоватся   прерыванием
1Ch,   так  как  при  этом  вызов  клиентов  AES  происходит  при
запрещенных прерываниях поэтому при длительном времени выполнения
клиента возможна потеря байтов в коммуникационном адаптере.

     Константы  для  типа  вызова  фоссила   и   генератора   AES
определены ниже.

     bCPUID  это  текущий  тип   процессора.   Он   должен   быть
обязательно проинициализирован. Величины такие:
     0 - 8086
     1 - 80186
     2 - 80286
     3 - 80386
     4 - 80486
     5 - 80586
     6 - 80686

После  возврата  из  функции  в  случае  успеха  будут  заполнены
остальные поля этой структуры:

поле cLibVer номер версии библиотеки  - lo(cLibVer) - младшая часть
hi(cLibVer) - старшая часть

поле cFossRev - ревизия стандарта фоссила

поле cDrivervRev  - версия конкретного фоссила , в формате BCD тоесть
старшие четыре бита - старшая часть версии , младшие - младшая

поле pDrvName - дальний указатель на ASCIIZ строку имени фоссила

поле vDrvType - слово тип Драйвера
если внутренняя процедура библиотеки смогла определить тип исполь-
зуемого коммуникационного драйвера, могут быть следующие значения.

        1 - BNU fossil
        2 - X00 fossil
        3 - VX00
        4 - Unknow fossil (неизвестный фоссил)
      свыше $10 - LLCL Drivers

в битовой  записи  rLibFlags  после  возврата  будут  утсановлены
следующие биты:

     бит 0 - доступность AES , если установлен то AES доступен
     бит  4  -  при  выполнении  функций  AES  будет  происходить
переключение стека.

     }

{Константы для удобства работы с битовой записью rLibFlags}
        FDIRECT=2 ; {вызов фоссила на прямую}
        FOLDINT14=0 ; {вызов через int 14h}
        FGEN=0 ; {генератор событий AES - фоссил}
        STCGEN=4 ; {генератор событий AES - таймер}
        UTCGEN=8 ; {генратор событий AES - таймер прерывание 1Ch}
        RTCGEN=$0C ; {генратор событий AES - часы реального времени}

{запись(структура) установок порта}
        type PortParam=record
                vPortNomber:word;
                wPortHandl:word;
                vPortSpeed:byte;
                vPortParity:byte;
                vPortStop:byte;
                vPortBits:byte;
                rFlowCtrl:byte;
                vTimeOut:word;
        end;

{Что касается PortParam:
   Данный тип структуры используется во многих функциях это:
        OpenChanel
        SetPort
        GetPortInfo
 OpenChanel и SetPort читают нужные параметры из этой структуры
 а GetPortInfo заполняет ее
 Теперь конкретно по полям:

поле vPortNomber  хоть  и  обозначено  как  слово  но  не  должно
превышать $FF Обозначает номер порта с которым идет работа

поле wPortHandl - хэндл устройства COMx где X - номер порта минус
еденица. При открытии канала делается попытка открыть соответству-
ющее устройство. Закрытие происходит в функции CloseChanel.
В случае неуспеха открытия wPortHandl = vPortNomber.

 поле vPortSpeed

0 - 300 бод
1 - 600 бод
2 - 1200 бод
3 - 2400 бод
4 - 4800 бод
5 - 9600 бод
6 - 19200 бод
7 - 38400 бод
8 - 57600 бод
9 - 115200 бод

поле vPortParity
       0 - без контроля четности
       1 - нечет
       2 - чет

поле vPortStop
       1 - 1 бит
       2 - 2 бита

поле vPortBits
       может быть от 5 до 8

поле vTimeOut
        таймаут в функциях ввода/вывода с ожиданием
        измеряется в 1/18.2 секунды
        может быть от 0 до 65535

поле rFlowCtrl представляет собой битовую запись управления потоком
вот ее поля от 7 до 0-вого бита сверху вниз
        Locked          ;Порт залочен
        DCD_Watch       ;WatchDog по DCD - по спаду производится
                        ;реинициализация порта
                        ;и фоссила(все что связано с этим портом).
        XonPass         ;Если установлен то символы XON/XOFF
                        ;проходят в буффер приема
        FRsrv (1 бит)   ;Бит 4 зарезервирован
        RxSoft          ;Бит установлен при XON/XOFF на приеме
        TxRxHrdw        ;Бит установлен при управлении потоком через DTR/DSR
        Hardw           ;Бит установлен при управлении потоком через RTS/CTS
        TxSoft          ;Бит установлен при XON/XOFF на передаче

Внимание! Если установлено TxRxHrdrw то это несовместимо с фосси-
лами.
Внимание! Если установлен бит  номер  7  то  при  вызове  функции
SetSpeed скорость меняться не будет. Что касается бита номер 6 то
если  он  установлен   то   после   потери   несущей   происходит
переинициализация порта,  сброс буферов и пр.  Это происходит при
вызове функции GetPortStat . }



{запись(структура) информации о канале}
        type ChanelInfo=record
                vTaskHndl:byte;
                vOpenTime:longint;
                vCloseTime:longint;
                vCharRx:longint;
                vCharTx:longint;
                vPortAssign:word;
        end;

{Что касается структуры ChanelInfo:

     Эта структура заполняется при вызове функцией  GetChanelInfo
или  CloseChanel

поле vTaskHandl  это номер канала (в данной версии всегда 0)
поле vOpenTime и vCloseTime

Время открытия и закрытия канала соответственно.  И  хотя  они  и
обозначены как longint они  являются  беззнаковыми  4-х  байтными
числами обозначающими количество квантов  по  1/18.2  секунды  от
полуночи (это все потому что в сраном паскале нет unsigned long).

поля vCharRx и vCharTx это кол-во принятых и переданных  символов
за весь сеанс канала они также как и предыдущее поле не longint а
unsigned long

поле vPortAssign номер порта (не адрес !) от 0 до $FF}

{запись(структура) информации о коммуникационном драйвере(фоссиле)}
        type FossInfo=record
                vInfoSize:word;
                cFossRev:byte;
                cDrvVer:byte;
                pDrvName:pointer;
                cRxBuffSz:word;
                cRxBuffFree:word;
                cTxBuffSz:word;
                cTxBuffFree:word;
                vScreenW:byte;
                vScreenH:byte;
                vSpeed:byte
        end;

{эта структура заполняется при вызове функции GetFossInfo
теперь подробнее о полях:

поле vInfoSize размер данной структуры и всегда равен $13 или меньше
поле cFossRev ревизия стандарта фоссила (см LibInfo )
поле cDrvVer версия фоссила (см LibInfo)
поле pDrvName дальний указатель на ASCIIZ строку имени драйвера
поле cRxBuffSz размер буфера приема
поле cRxBuffFree кол-во свободного места в буфере приема
поле cTxBuffSz размер буфера передачи
поле cTxBuffFree кол-во свободного места в буфере передачи
поле vScreenW ширина экрана в символах
поле vScreenH высота экрана в символах
поле  vSpeed  установленная  скорость  порта   (пока   это   поле
заполняется всякой}

──────────────────────────────────────────────────────────────────────
                         СПИСОК ФУНКЦИЙ
{Теперь что касается функций.
Следующие функции хоть не полностью но отлажены и работают}

   {$F+ $L+ $D+}

         function InitFLib(port:byte;p:pointer):integer;external;
         function OpenChanel(a:pointer):integer;external;
         function CloseChanel(a:byte;p:pointer):integer;external;
         function InitPort:integer;external;
         function SetPort(p:pointer):integer;external;
         function DoPause(a:longint):integer;external;
         function ReadChar:integer;external;
         function WriteChar(a:char):integer;external;
         function PeekChar:integer;external;
         function WaitChar:integer;external;
         function WriteWaitChar(a:char):integer;external;
         function SendBreak(a:byte):integer;external;
         function ChangeDTR(a:byte):integer;external;
         function ToggleDTR:integer;external;
         function PulseDTR(a:byte):integer;external;
         function ReceiveCtrl(Mode:byte):integer;external;
         function ClearRxQueue:integer;external;
         function ClearTxQueue:integer;external;
         function WriteBlock(a:word;p:pointer):integer;external;
         function ReadBlock(a:word;p:pointer):integer;external;
         function ChangeSpeed(a:byte):integer;external;
         function GetPortStat:integer;external;
         function WatchDCD(a:byte):integer;external;
         function ChangeChanelPort(a:word):integer;external;
         function GetChanelInfo(p:pointer):integer;external;
         function GetPortInfo(p:pointer):integer;external;
         function GetAsyncInfo(p:pointer):integer;external;
         function EndWork:integer;external;
         function SendString(p:pointer):integer;external;
         function XXPass(b:byte):integer;external;
         function GetContextStr:pointer;external;
         function GetXtendPortStat:integer;external;
         function ChangeTimeOut(Time:word):integer;external;

     {$L llcl_srv.obj}
        ┌─────────────────────────────────────────────────┐
        │                                                 │
        │    ФУНКЦИИ ИНИЦИАЛИЗАЦИИ И ДЕИНИЦИАЛИЗАЦИИ    ──┼─
────────┴─────────────────────────────────────────────────┘
──────────────────────────────────────────────────────────────────────────
{Начнем:
                        ФУНКЦИЯ InitFLib

     InitFLib(Port:byte;pLibInfo:pointer):integer

     InitFLib  в  качестве  первого  параметра   принимает   байт
номера порта
     Второй параметр это указатель на структуру типа  LibInfo  Из
этой  структуры  она  некоторые  вещи  читает  а  остальные  поля
заполняет.

        type LibInfo=record
                pReleaseSlice:pointer;
                fpAESStack:pointer;
                fpServerStack:pointer;
                wAESStckSize:word;
                wServerStckSize:word;
                cLibver:word;
                cFossilRev:byte;
                cDriverRev:byte;
                cMaxFossFunc:byte;
                pDrvName:pointer;
                rLibFlags:byte;
                wDrvType:word;
                bCPUID:byte;
         end;

     Перед вызом вы должны установить pReleaseSlice на  процедуру
отдачи кванта  времени,  это  далний  указатель.  Если  процедура
отсутствует то это поле должно быть проинициализировано в ноль.

     fpAESStack нужно проинициализировать указателем на стек AES.
Подробнее смотри вначале описание полей структуры LibInfo

     wAESStckSize нужно проинициализировать размером стека AES

     wServerStckSize нужно проинициализировать в ноль

     rLibFlags - битовая запись
     Необходимо проинициализировать бит 1
     Сбросить его если старый стиль  вызова  фоссила  и  наоборот
елси новый стиль.(константы FDIRECT и FOLDINT14)
     Необходимо проинициализировать биты 3 и 2 в значения:
     FGEN, STCGEN, UTCGEN или RTCGEN

     wCPUID нужно проинициализировать типом процессора.

     После возврата  в  случае  успеха  (результат  положительное
число) Будут заполнены следующие поля:

     cLibver:word;      Версия библиотеки
     cFossilRev:byte;   Ревизия фоссил-стандарта
     cDriverRev:byte;   Версия данного фоссил драйвера
     cMaxFossFunc:byte; Максимальный номер функции поддерживаемой
     pDrvName:pointer;  Указатель на ASCIIZ строку имени драйвера
     wDrvType:word; Тип драйвера
     Тип драйвера может быть : 1- BNU 2-X00 3-другой фоссил

     Также  будут  соответствующим  образом  изменены  биты   0,4
битовой записи rLibFlags.

     Подробнее sLibInfo описана в начале.

──────────────────────────────────────────────────────────────────────────
                       ФУНКЦИЯ OpenChanel

     OpenChanel (pPortParam:pointer):integer

     OpenChanel  в  качестве  параметра  принимает  указатель  на
структуру типа PortParam откуда берет параметры порта  (структуру
не изменяет)
             type PortParam=record
                vPortNomber:word;
                wPortHandl:word;
                vPortSpeed:byte;
                vPortParity:byte;
                vPortStop:byte;
                vPortBits:byte;
                rFlowCtrl:byte;
                vTimeOut:word;
        end;

Вы должны проинициализировать все поля этой структуры кроме поля wPortHandl.
Описание смотри в начале данного тектса.

──────────────────────────────────────────────────────────────────────────

                       ФУНКЦИЯ CloseChanel

     CloseChanel (Force:byte;pChanelInfo:pointer):integer

     CloseChanel в качестве параметра Force  берет  байт  который
может быть либо 0  либо  отличный  от  нуля(см.ниже)  В  качестве
второго  параметра  принимает   указатель   на   структуру   типа
ChanelInfo которую заполняет.
     Если при вызове функции оказалось что уже ктото(например  из
таймерного прерывания) работает с открытым каналом то если первый
параметр :  0 - то выходит  с  ошибкой  TSSBUSY  и  не  заполняет
структуру ChanelInfo,  не 0 -  то  игнорирует  ошибку  TSSBUSY  и
закрывает канал и порт и заполняет ChanelInfo.

        type ChanelInfo=record
         vTaskHndl:byte; Идентификатор канала
         vOpenTime:longint;  Время открытия в тиках от полуночи
         vCloseTime:longint; Время закрытия в тиках от полуночи
         vCharRx:longint;    Всего принято байт
         vCharTx:longint;    Всего передано байт
         vPortAssign:word;   Номер порта с которым шла работа
        end;

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ Suspend

     Suspend

     Suspend вызывается без аргументов и не возвращает никаких значений

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ EndWork

     EndWork ():integer

     EndWork функция ничего не  принимает,  и  всегда  возвращает
окей эту функцию нужно вызывать когда вы  окончательно  закончили
работу с библиотекой, тоесть она комплементарна InitFLib.
          ┌───────────────────────────────────────────────┐
          │                                               │
          │ ФУНКЦИИ ИНИЦИАЛИЗАЦИИ И УСТАНОВКИ ПОРТОВ      │
          │                                               ┼─
──────────┴───────────────────────────────────────────────┴───────────────


                         ФУНКЦИЯ SetPort

     SetPort (pPortParam:pointer):integer

     SetPort принимает указатель на структуру  типа  PortParam  и
переустанавливает параметры порта но не инициализирует его заново
тоесть все линии порта  и  буфера  остаются  без  изменения.  Для
инициализации порта с этими  параметрами  нужно  вызвать  функцию
InitPort.
──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ InitPort

     InitPort ():integer

     InitPort без параметров  -  инитит  порт  в  соответствии  с
установками сделанными с помощью OpenChanel или SetPort -  ПОЛНАЯ
ИНИЦИАЛИЗАЦИЯ со сбросом всех буферов
──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ChangeSpeed

     ChangeSpeed (Speed:byte):integer

     ChangeSрeed  принимает  в  качестве  параметра  Speed   байт
скорости(описание  смотри  в   описании   структуры   рortрaram),
возвращает ошибку или ничего.  Скорость меняется только если порт
не залочен,  иначе просто ничего не происходит.  Эта штука  нужна
при Non ARQ если не лочен порт.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ WatchDCD

     WatchDCD (Mode:byte):integer

     WatchDCD  в  качестве  параметра  Mode  принимает  байт   со
значением 0 (выключить) или 1- включить. Просто устанавливает или
сбрасывает бит во внутренних структурах данных  библиотеки.  Этот
бит тотже самы  который  вы  могли  установит  при  инициализации
записи(структуры) типа рortрaram в поле rFlowCtrl.  Если этот бит
установлен  то  при   пропадании   несущей   будет   производится
переинициализация  порта  и  сброс  буферов.   Подробнее   смотри
GetPortStat. Возвращает ошибку или ничего.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ChangeChanelPort

     ChangeChanelPort (Port:word):integer

     ChangeChanelPort принимает слово с номером порта(  не  более
$FF).  Функция изменяет номер порта с которым работает  канал.  В
случае если порт не был инициализирован,  функция  инициализирует
его теми  установками  которые  были  заданы  раннее  при  вызове
функций OрenChanel и других меняющих установки  порта.  ВНИМАНИЕ!
Проверяйте  код  ошибки  возвращенный  функцией,  может  появится
ошибка NOFOSS что означает что фоссил не настроен  на   работу  с
этим портом.В этом случае другие функции (кроме  InitPort)  будут
работать, но результаты не предсказуемы.  В случае этой ошибки вы
можете либо  закончить  работу  (CloseChanel)  либо  вернутся  на
прежний порт.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ChangeTimeOut

     ChangeTimeOut (Time:word):integer

     Изменяет время таймаута для функций ввода/ввыода с ожиданием.
     Аргумент - время в тиках.
     Возвращает ошибку типа TERR_NOLIB или TERR_NOACTIV
  ──────────────────────────────────────────────────────────────────────

           ┌───────────────────────────────────────┐
           │                                       │
           │  ФУНКЦИИ УПРАВЛЕНИЯ ПОТОКОМ И ПОРТАМИ │
           └───────────────────────────────────────┘
──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ChangeDTR

     ChangeDTR (Mode:byte):integer

     ChangeDTR принимает байт либо 1 (установить линию DTR)  либо
0 (сбросить)

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ToggleDTR

     ToggleDTR ():integer

     ToggleDTR без параметров - изменяет состояние линии  DTR  на
противоположное.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ PulseDTR

     PulseDTR (Time:byte):integer

     PulseDTR принимает  байт  время  в  квантах  по  1/18.2  сек
который говорит сколько держать DTR в  одном  состоянии.  Функция
пульсирует линией DTR

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ReceiveCtrl

     ReceiveCtrl (Mode:byte):integer

     ReceiveCtrl принимает байт либо 1 (разрешить прием)  либо
0 (запретить прием).
     Служит для  предотвращения  потери  данных  на  медленных
машинах.


──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ XXPass

     XXPass (Mode:byte):integer

     XXPass принимает в  качестве  параметра  Mode  байт  который
может быть равен либо 0  либо  1  .  Функция  управляет  тем  как
Драйвер будет обрабатывать символы  XON/XOFF  .  Если  Mode=1  то
символы будут беспрепятственно  проходить  из  порта  в  приемный
буфер , иначе они проходить не будут.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ SendBreak

     SendBreak (Time:byte):integer

     SendBreak в качестве параметра Time принимает  байт  который
содержит количество квантов по 1/18.2  секунды  обозначающий  как
долго посылать BREAK последовательность (на это нужно не знаю, но
в фоссиле есть)

──────────────────────────────────────────────────────────────────────

                ┌─────────────────────────────┐
                │  ФУНКЦИИ РАБОТЫ С БУФЕРАМИ  │
                │                             │
──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ClearRxQueue

     ClearRxQueue ():integer

   ClearRxQueue без параметров , очищает буфер приема фоссила

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ClearTxQueue

     ClearTxQueue ():integer

   ClearTxQueue без параметров, очищает буфер передачи фоссила
              ┌─────────────────────────────────┐
              │                                 │
              │  ФУНКЦИИ ПРИЕМА/ПЕРЕДАЧИ ДАННЫХ │
              └─┬─────────────────────────────┬─┴─


──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ReadChar

     ReadChar ():integer

     ReadChar без параметров - возвращает принятый символ или код
ошибки. Символа не ждет - если его нет то возвращает RXEMPTY

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ PeekChar

     PeekChar ():integer

     PeekChar то же что и ReadChar НО НЕ ИЗВЛЕКАЕТ из буфера.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ WriteChar

     WriteChar (Char:byte):integer

     WriteChar принимает в качестве параметра байт -  символ  для
передачи Если место есть то передает иначе возвращает TXFULL


──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ WaitChar

     WaitChar ():integer

     WaitChar тоже что и ReadChar НО если символа нет в буфере то
не возвращает управление до тех пор пока не получит его либо пока
не наступит таймаут

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ WriteWaitChar

     WriteWaitChar (Char:byte):integer

     WriteWaitChar тоже что и  WriteChar  но  если  нет  места  в
буфере ждет пока оно не появится или не наступит таймаут

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ WriteBlock

     WriteBlock (Count:word;pBuff:pointer):integer

     WriteBlock первый параметр Count сколько символов закинуть в
буфер фоссила ( но не более $7FFF) второй pBuff это указатель  на
буфер где лежит блок.  Возвращает  <  0  если  ошибка  или  число
действительно переданных символов.  Работает без  ожидания  (если
нет места то возвращает TXFULL)

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ ReadBlock

     ReadBlock (Count:word;pBuff:pointer):integer

     ReadBlock все что и в предыдущей  только  читает  из  буфера
фоссила в ваш внутренний  буфер  тоесть:  первый  параметр  Count
сколько максимум можно записать в  ваш  буфер  второй  pBuff  это
указатель на ваш  буфер.  Возвращает  тоже  что  и  WriteBlock  .
Работает без ожидания (если нет символов то возвращает RXEMPTY

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ SendString

     SendString (String:pointer):integer

     SendString функция принимает в качестве параметра  указатель
ASCIIZ строки и посылает ее в модем.  Если буфер фоссила полон то
ждется до таймаута.  Возвращает ошибку TOUT,  NOACTIV,  TSSBUSу и
другие стандартные.

────────────────┴─────────────────────────────┴───────────────────────────

   ┌────────────────────────────────────────┐
  ┌┴ ФУНКЦИИ ПОЛУЧЕНИЯ РАЗЛИЧНОЙ ИНФОРМАЦИИ │
  │  О БИБЛИОТЕКИ И  ПОРТАХ                 │
  └─────────────────────────────────────────┘

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ GetPortStat

     GetPortStat ():integer

     GetPortStat Параметров нет.  Возвращает либо  ошибку  (число
меньше 0) или битовую запись следующего формата:

        бит 15 - всегда ноль, так как число должно быть положительно
        бит 14  - буфер передачи пуст (маска ST_TXEMрT)
        бит 13 - есть место в буф.передачи (маска ST_TXAV)
        бит 9 - буф. приема был переполнен (маска ST_OVRN)
        бит 8 - есть данные в буфере приема (маска ST_RDA)
        бит 7 - обнаружена несущая (маска ST_DCD)
        бит 6 - обнаружен звонок   (маска ST_RING)
        бит 3 - всегда 1
        бит 1 - DTR активна        (маска ST_DTR)
        бит 0 - предыдущее состояние DCD  (маска ST_PREVDCD)

     Также именно эта функция выполняет  переинициализацию  порта
после пропадания несущей если установлен был WatchDCD.  Из  этого
следует что чтобы это происходило вы должны вызывать эту  функцию
достаточно часто, но это так и будет, так как узнать произошол ли
конект можно только с ее помощью , ну и проверка несущей во время
конекта происходит почти постаянно, особенно в случае длительного
отсутствия данных или невозможности передать свои.

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ GetXtendPortStat

     GetXtendPortStat ():integer

     GetXtendPortStat вызывается без параметров . Возвращает либо
ошибку (TERR_PORTN ) либо  битовую  запись.  Конкретное  значение
каждого   бита   зависит   от   типа   используемого    драйвера.
Идентификация каждого бита  должна  быть  произведена  с  помощью
функции GetContextStr  которая  возвращает  указатель  на  ASCIIZ
строку названий каждого бита.  Приведем формат битовой записи для
драйверов типа FOSSIL :
         бит 11  - DCD  установлен если есть несущая
         бит 10  - RNG   обнаружен звонок
         бит  9  - DSR  модем готов к обмену данными
         бит  8  - CTS  модем может принимать данные
         бит  7  - TXD   идет передача символа
         бит  6  - BRK  обнаружен сигнал BREAK
         бит  5  - SYN  ошибка кадра (нето кол-во стоп бит и т д)
         бит  4  - PRT  ошибка контроля четности
         бит  3  - OVR  Оверран - был принят символ а предыдущий непрочитан
         бит  2  - RXD   Принят байт
         бит  1  - RTS  компьютер может принимать данные
         бит  0  - DTR  компьютер готов к обмену данными

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ GetContextStr

     GetContextStr ():pointer

     GetContextStr возвращает указатель на ASCIIZ строку названий
битов  битовой  записи  возвращаемой  функцией  GetXtendPortStat.
Названия разделены пробелами.  В  случае  ошибки  при  выполнении
функции (ошибка типа того что для установленного  текущим  номера
порта невозможно получить  информацию  )  ВОЗВРАЩАЕТСЯ  НЕОБЫЧНАЯ
ОШИБКА а нулевой указатель.  Приведем вид строки возвращаемой при
установленном драйвере типа FOSSIL :

     DTR RTS RxD OVR PRT SYN BRK TxD CTS DSR RNG DCD
     Конец строки отмечен числом 0 (ASCIIZ строка)

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ GetPortInfo

     GetPortInfo (pPortParam:pointer):integer

     GetPortInfo принимает дальний указатель на структуру(запись)
типа рortрaram и заполняет  ее  поля  (  описание  рortрaram  см.
раньше)

──────────────────────────────────────────────────────────────────────────

                        ФУНКЦИЯ GetAsyncInfo

     GetAsyncInfo (pFossInfo:pointer):integer

     GetAsуncInfo     принимает     дальний     указатель      на
структуру(запись) типа FossInfo описание которой данно в  начале.
Эта информация относится  к  порту  с  которым  в  данный  момент
работает канал. Функция заполняет данную структуру.
──────────────────────────────────────────────────────────────────────
                        ┌──────────────────┐
                        │ДРУГИЕ ФУНКЦИИ    │
                        └──────────────────┘


                         ФУНКЦИЯ DoPause

     DoPause (Time:longint):integer

     DoPause принимает в качестве параметра Time  четырехбайтовое
беззнаковое в квантах по 1/18.2 секунды и  возвращает  управление
после данной задержки.

-------------------------------------------------------------------

   В минимальном комплекте должно быть так:

   InitFLib (передаем указатель на структуру типа LibInfo)
   OрenChanel (передаем указатель на структуру типа PortParam)

nextevent:

   GetPortStat {ждем несущую тоесть коннект}

   а далеее работаем через Read/Write (если попали от ChangeDTR не забудь
   установить DTR опять, если от рulse то не нужно[если конечно перед рulse
   DTR стояло])

   в конце рulse/Change DTR goto nextevent

   CloseChanel
   EndWork

     Запомните  функция  OрenChanel  сама  инитит   порт   потому
специально InitPort вызывать не нужно

   Также CloseChanel сбрасывает DTR


                            ВНИМАНИЕ!
     Все   функции    библиотеки    работают    с    прерываниями
установленными как есть В связи с этим надо быть  осторожным  при
вызове функций оперирующих с временными парметрами (Read/Write  с
ожиданием, Doрause,  рulseDTR,SendBreak) Так как если у вас перед
их  вызовом  были  запрещены  прерывания  вы  можете  никогда  не
получить управления назад)


     ТАКЖЕ! Все имена полей записей,  записей и всего чего угодно
кроме функций вы можете менять как угодно они  меня  не  колышат.
НЕМЕНЯЙТЕ определения функций так как при этом  в  паскале  может
изменится способ передачи параметров  и  усе  не  будет  работать
(тоесть function tttt(a:bуte) примет  переменую  по  значению,  а
function tttt(var a) примет указатель на переменную.}
